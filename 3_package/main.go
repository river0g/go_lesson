package main

import (
	"fmt"
	"github.com/tenntenn/greeting"
)
var msg string = "hello"
func f() { println(msg) }
func main() {
	fmt.Println("hi")

	/* Goのプログラムの構成要素
		- Goを構成するものは以下になる
			- パッケージ
				- 関数や変数、定数、型を意味ある単位でまとめたもの。
				- Goはパッケージを組み合わせることで構成される。
			
			- 型
				- データの種類を表したもの

			- 関数
				- 処理を意味ある単位でまとめたもの
				- パッケージに属さない組み込み関数も存在する(make, printlnなど)

			- 変数
				- 処理中に使用するデータを格納するもの
			
			- 定数(名前付き定数)
				- コンパイル時から不変の値に名前をつけたもの
				- PI = 3.14, E = 2.17など

		- Goのプログラムの構成とパッケージ
			- mainパッケージから別のパッケージをインポートする
				- パッケージをインポートすることにより様々な機能が使える。

		- 複数のファイル
			- パッケージは複数のファイルで構成可能
			- どういう分け方をしても良い
			- 型の定義とメソッドの定義が別れていても良い
			- 同じディレクトリないで複数のパッケージが混在するのはダメ
			- インポート文はファイルごとに記述する

		- パッケージの種類
			- mainパッケージ
				- main関数の存在するパッケージ
				- プログラムの起点(エントリポイント)となるパッケージ
				- 実行可能なGoのプログラムのばいいには必ず存在する。
			- 標準パッケージ
				- Goが最初から用意しているパッケージ
				- 100以上のパッケージが存在する
			- サードパティパッケージ
				- 第三者(自分も含む)が開発したパッケージ
				- インターネット上で公開されていることが多い
				- インストールすることで使える
				- ライブラリとも呼ばれる。

		- パッケージのインポート
			- 他のパッケージの機能を使う
				- インポートすることで使えるようになる
				- インポートはIDEやgoimportsなどのツールに任せる
			- パッケージをインポートしてできること
				- 別のパッケージで用意された機能を使用できる。
					- 変数、関数、定数など
		import (
			"context" // 標準pkg
			"fmt" // 標準pkg

			"github.com/taro/greeting"
		)
		標準とサードパティ製をインポートするときは一行空行を空けることが多い。


		- パッケージ名のエイリアス
			- 別名をつける
				- インポートパスの左側に変えたい名前を書く
				- 同じパッケージ名のパッケージを使いたい場合に使う - (1)
				- インポートパスとパッケージ名が一致していない場合に用いる - (2)
		package (
			"fmt"
			"sync"

			mysync "github.com/taro/sync" // 上のsyncパッケージと名前が衝突している => (1)
			greeting "github.com/taro/greeting/v2" // インポートパスとパッケージ名が一致していない => (2)
		)
		func main() {
			fmt.Println(greeting.DO())
		}


		- パッケージ外へのエクスポート
			- エクスポート
				- 先頭を大文字にした識別子がエクスポートされる。他ファイルでインポートしたいなら大文字に使用。
				- 他のパッケージから利用できるようになる。
			var Hoge string // エクスポートできる
			var fuga string // エクスポートできない
			- ライブラリ
				- main関数のないGoのプログラム
				- エクスポートされたものを使用する。


		- GOPATH
			- Goのソースコードやビルドされたファイルが入るパスが設定される
			- インポートされるパッケージもここから検索される
		- GOPATHの設定方法
			- 環境変数として設定される
			- デフォルトが決まっている
				- Unix系: $HOME/go
			- 複数設定できる
			- go env GOPATHコマンドでGOPATHが取得可能
	*/


	/* 自モジュール内のpkgをインポート
		- 以下の構成とする
		mymodule/
			go.mod
			main.go
			mypkg/
				- mypkg.go
		- 同一モジュールから他パッケージのものをインポートするには、
			- import "モジュール名/パッケージ名" とする。
		上記に従って、main.goからmypkgをインポートするには、
		--main.go--
		import "mymodule/mypkg"
		とする。
		
	*/

	

	/* パッケージ変数とスコープ
		- スコープ
			- 識別子(変数名、関数名)を参照できる範囲
			- 参照元によって所属するスコープが違う
			- 親子関係があり、親のスコープの識別子は参照できる。
			var n int
			func main() {
				println(n) // 親スコープの識別子を参照している。
			}
		- Goのスコープ
			- レキシカルスコープを採用
			- スコープは4種類
				- ブロック
				- ファイル
				- パッケージ
				- ユニバース
		

		- ブロックスコープについて
			- ブロックごとのスコープ
				- 関数やif, forなどのブロック単位のスコープ
				- ブロック内で宣言した識別子はブロック内でしか参照できない
			func f() {
				n := 100
				println(n)
			}
			func g() {
				n := 200 // 関数fのnとは別のもの
				println(n)
			}
		
		- ファイルスコープ
			- ファイルごとのスコープ
				- ファイル内でインポートしたパッケージを保持するスコープ
				- パッケージ以外は対象としていない
			import "fmt" // fmtがファイルスコープになる

		- パッケージスコープ
			- パッケージごとのスコープ
				- パッケージ単位になる
				- 大文字から始まる識別子は他のパッケージからも参照できる。

		- パッケージ変数
			- 関数間で変数を共有するためには？
				- 関数内で定義した変数は関数を出ると消えてしまう
				- 関数を跨いだデータの共有には2種類ある。
					- パッケージ変数
					- メソッドを用いる
				- 関数と同じレベル変数を定義すればOK

		- ユニバーサルスコープ
			- 組み込み型や組み込み関数を保持するスコープ
				- プログラム実行時からずっと存在するスコープ
				- ルートとなるスコープ
	*/
	f() // main外ののmsgを参照している
	msg = "hi gophers" // 親スコープでmsgを定義しているため:=やvarでなく、=になる。
	f() // このスコープ内のmsg(hi gophers)を参照している



	/* パッケージの初期化
		- パッケージの初期化
			- 依存パッケージの初期化
				- import しているパッケージリストを出す。
				- 依存関係を解決して依存されていないパッケージから初期化していく
			- 各パッケージの初期化
				- パッケージ変数の初期化をする
				- init関数の実行を行う

		- init関数
			- パッケージの初期化を行う関数
				- パッケージの初期化時に呼び出される関数
				- 複雑な初期化を行う場合に用いる
					- パッケージ変数への代入分だけでは表現できない場合
				- 1パッケージに複数用意しても良い
				- 1ファイルに複数用意しても良い
				- 実行順がシビアなものはinit関数に書かない
				- エラーハンドリングが必要な処理は書かない
				- init関数は明示的に呼び出せない
	*/


	/* ライブラリのバージョン管理
		- go getでライブラリの取得をする
			- go get
				- Goのライブラリなどを取得するコマンド
				- 依存するライブラリも一緒にダウンロードしてくれる
				- 指定した場所からダウンロードandインストールしてくれる
				- 一度取得したものは二度取得しない
				- -u オプションでダウンロード強制する。
		$ go get github.com/taro/greeting
		$ ls $GOPATH/src/github.com/taro/greeting
		README.md greeting.go
	*/

	/* ライブラリを取得してみよう
		- github.com/tenntenn/greetingをgo getする
			go get github.com/tenntenn/greeting
		- mainパッケージから使ってみる
			- import パスを"github.com/tenntenn/greeting"にしてインポートする。
	*/
	fmt.Println(greeting.Do())


	/* GoDocを生成する
		- GoDocとは
			- ソースコード情に書かれたコメントをドキュメントとして扱う
			- JavaのJavaDocに似ているらしい
				- @paramなど凝った記法はない
			- エクスポートされたものに書くことが多い
		
		- pkg.go.devを使ってパッケージドキュメントを読む
			- pkg.go.devは自動でGoDocを生成するサービス
			- URLの後ろにインポートパスを書いてアクセスする。
				- https://pkg.go.dev/github.com/tenntenn/greeting
					- わかりやすい。
		
		- Go modules
			- 標準モジュール管理の仕組み
				- https://golang.org/ref/mod
				- Go1.13で正式導入

			- modulesの特徴
				- ビルド時に依存関係を解決する (go toolのように)
				- ベンダリングが不要になる
					- ベンダリングとは依存関係をプロジェクトのリポジトリに入れてしまうことである。
						- pythonでいうvenvのsite-packageなど(実際にはgitにアップロードしない)の対極にあるもの。
				- 新しくモジュールという概念単位でバージョン管理する
				- 互換性がなくなる場合はインポートパスを変える。
				- 可能な限り古いバージョンが優先される
		
			
		- goinstallの登場
			- 2010年2月に登場
				- GitHubやBitbucketからダウンロードして配置する。
				- Makefileほどの柔軟性はないが、利便性が向上。
				- 2012年2月のGo1.0リリースでGo getに

		- go getで解決したこと
			- 簡単にビルドができるようになった
			- 作ったものを簡単に公開、再利用できるようになった。
				- 現在のGoコミュニティを形成する上で重要なファクタ
				- go getすることで簡単に他人のパッケージを利用できる
			- ビルドしすてむを意識しなくて良い
				- 依存関係の解決方法などはかってにやってくれる。

		- go getで解決できなかったこと
			- バージョン付けとAPIの安定性
				- バージョン付けができない
				- アップデートによって何が変わるのかユーザーに提示できない
				- gopkg.inなどの登場
			- ベンダリングとビルドの再現可能性
				- ビルドの再現性が取れない
				- 取得時に常に最新をみてしまうこと
				- godep, glide, GBなどの登場
				- ベンダリングの対応(Go1.5以上)

		- ベンダリング
			- ライブラリのベンダリング
				- vendeor以下に置くとimportで優先される
				- バージョン指定不可
			vendor > github.com > taro > cli
	*/


	/* ビルドが解決できない例
		- 1. パッケージDのインストール
			- go get D // D: 1.0
		- 2. パッケージCのインストール
			- go get C // C:1.8, D>=1.4依存, 1.でインストールしたものは古い
		- 3. パッケージDの更新
			- go get -u D // C: 1.8, D>=1.4依存, ここでD:1.6になるがこのバージョンにバグがあった。
		結果としてうまくビルドができない
	*/

	/* バージョン管理ツールの登場
		- サードパーティ製のツール類が登場し始める
			- GB
				- https://getgb.io/
				- プロジェクトベースのビルドツール
			- glide
				- https://github.com/Masterminds/glide
				- Goコミュニティで多く使われていたパッケージ管理ツール
		サードパーティが台頭してきたので標準のものが必要になってきた。
	*/


	/* depの登場
		- 公式によるバージョン管理の導入実験
			- GopherCon 2016のHack Dayで議論が行われた
			- そこからdepが登場した。
			- https://github.com/golang/dep
		- The New Era of Go Package Management
			- GopherCon 2017においての発表
			- depのやっていき方を発表
			- semverの推奨
		
		結果としてdepはgoツールに直接導入されるものではなかった。
	*/

	/* そしてmodules(vgo)へ
		- modules(vgo)で提案すること
			- Import Compatibility Rule
			- Minimal Version Selection
			- モジュールの導入
			- 現在のワークフローを壊さずにgo toolに導入する。
		modulesが普及するにはGoコミュニティの協力が必要
	*/

	/* Import Compatibility Rule
		- importパスが同じ場合は後方互換性を維持する
			- 後方互換性を保てない場合はインポートパスを変える
		import "github.com/taro/hoge"
		↓
		import hoge "github.com/taro/hoge/v2"
	*/

	/* Minimal Version Selection
		- 最小バージョンの選択
			- 選択できるバージョンの内最も古いバージョンを選択。
			- どんどんバージョンアップされても常に同じ(=古い)ものを使う
			- 特定のバージョンを指定すれば新しいものを使うことはできる
			- 依存モジュールの下限だけ指定することによって、一位にビルドに使用するバージョンが特定できる。
	*/

	/* モジュール
		- バージョン付けを行う単位
			- go.modファイルを使って依存モジュールを記述
			- バージョンはsemverで記述する
			- 特定のコミットも指定できる
		module "rsc.io/hello" <- モジュール名

		require (
			↓ 依存しているモジュール
			"golang.org/x/text" v0.0.0-20180208...-4e...54
			"rsc.io/quote" v1.5.2 <- 依存しているモジュールのバージョン
		)
	*/

	/* セマンティックバージョニング
		- バージョンの付け方のルール
			- semverと略される
			- v0.0.2やv1.1.1などと表記する。
		- バージョンの上げ方
			- 互換が崩れる場合はメジャーバージョン (例: v1.2.3 -> v2.0.0)
			- 機能追加の場合はマイナーバージョン (例; v1.2.3 -> v1.3.0)
			- バグ修正の場合はパッチバージョン (例; v1.2.3 -> v1.2.4)
	*/

	/* go modコマンド
		- go modコマンドを有効にする
		- go modコマンドのサブコマンド
			- "go mod init モジュール名" 
				- 指定したモジュール名でgo.modファイルを作成する。モジュール名を省略するとGOPATHから推測する。
			- "go mod tidy" 
				- 使用していないモジュールのgo.modからの削除。必要なモジュールのダウンロードとgo.modへの追加
			- "go mod why" 
				- 指定したバッケージの必要な理由を表示
			- "go mod vendor"
				- 依存するパッケージをvendor以下にコピーする
	*/


	/* TRY
		modulesを使ってみよう
			- modules用のプロジェクトを作成する
				- github.com/tenntenn/greetingのv1.0.0を使ってみる
				- github.com/tenntenn/greetingのv2.0.0を使ってみる
	*/

}