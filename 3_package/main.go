package main

import (
	"fmt"
)
var msg string = "hello"
func f() { println(msg) }
func main() {
	fmt.Println("hi")

	/* Goのプログラムの構成要素
		- Goを構成するものは以下になる
			- パッケージ
				- 関数や変数、定数、型を意味ある単位でまとめたもの。
				- Goはパッケージを組み合わせることで構成される。
			
			- 型
				- データの種類を表したもの

			- 関数
				- 処理を意味ある単位でまとめたもの
				- パッケージに属さない組み込み関数も存在する(make, printlnなど)

			- 変数
				- 処理中に使用するデータを格納するもの
			
			- 定数(名前付き定数)
				- コンパイル時から不変の値に名前をつけたもの
				- PI = 3.14, E = 2.17など

		- Goのプログラムの構成とパッケージ
			- mainパッケージから別のパッケージをインポートする
				- パッケージをインポートすることにより様々な機能が使える。

		- 複数のファイル
			- パッケージは複数のファイルで構成可能
			- どういう分け方をしても良い
			- 型の定義とメソッドの定義が別れていても良い
			- 同じディレクトリないで複数のパッケージが混在するのはダメ
			- インポート文はファイルごとに記述する

		- パッケージの種類
			- mainパッケージ
				- main関数の存在するパッケージ
				- プログラムの起点(エントリポイント)となるパッケージ
				- 実行可能なGoのプログラムのばいいには必ず存在する。
			- 標準パッケージ
				- Goが最初から用意しているパッケージ
				- 100以上のパッケージが存在する
			- サードパティパッケージ
				- 第三者(自分も含む)が開発したパッケージ
				- インターネット上で公開されていることが多い
				- インストールすることで使える
				- ライブラリとも呼ばれる。

		- パッケージのインポート
			- 他のパッケージの機能を使う
				- インポートすることで使えるようになる
				- インポートはIDEやgoimportsなどのツールに任せる
			- パッケージをインポートしてできること
				- 別のパッケージで用意された機能を使用できる。
					- 変数、関数、定数など
		import (
			"context" // 標準pkg
			"fmt" // 標準pkg

			"github.com/taro/greeting"
		)
		標準とサードパティ製をインポートするときは一行空行を空けることが多い。


		- パッケージ名のエイリアス
			- 別名をつける
				- インポートパスの左側に変えたい名前を書く
				- 同じパッケージ名のパッケージを使いたい場合に使う - (1)
				- インポートパスとパッケージ名が一致していない場合に用いる - (2)
		package (
			"fmt"
			"sync"

			mysync "github.com/taro/sync" // 上のsyncパッケージと名前が衝突している => (1)
			greeting "github.com/taro/greeting/v2" // インポートパスとパッケージ名が一致していない => (2)
		)
		func main() {
			fmt.Println(greeting.DO())
		}


		- パッケージ外へのエクスポート
			- エクスポート
				- 先頭を大文字にした識別子がエクスポートされる。他ファイルでインポートしたいなら大文字に使用。
				- 他のパッケージから利用できるようになる。
			var Hoge string // エクスポートできる
			var fuga string // エクスポートできない
			- ライブラリ
				- main関数のないGoのプログラム
				- エクスポートされたものを使用する。


		- GOPATH
			- Goのソースコードやビルドされたファイルが入るパスが設定される
			- インポートされるパッケージもここから検索される
		- GOPATHの設定方法
			- 環境変数として設定される
			- デフォルトが決まっている
				- Unix系: $HOME/go
			- 複数設定できる
			- go env GOPATHコマンドでGOPATHが取得可能
	*/


	/* 自モジュール内のpkgをインポート
		- 以下の構成とする
		mymodule/
			go.mod
			main.go
			mypkg/
				- mypkg.go
		- 同一モジュールから他パッケージのものをインポートするには、
			- import "モジュール名/パッケージ名" とする。
		上記に従って、main.goからmypkgをインポートするには、
		--main.go--
		import "mymodule/mypkg"
		とする。
		
	*/

	

	/* パッケージ変数とスコープ
		- スコープ
			- 識別子(変数名、関数名)を参照できる範囲
			- 参照元によって所属するスコープが違う
			- 親子関係があり、親のスコープの識別子は参照できる。
			var n int
			func main() {
				println(n) // 親スコープの識別子を参照している。
			}
		- Goのスコープ
			- レキシカルスコープを採用
			- スコープは4種類
				- ブロック
				- ファイル
				- パッケージ
				- ユニバース
		

		- ブロックスコープについて
			- ブロックごとのスコープ
				- 関数やif, forなどのブロック単位のスコープ
				- ブロック内で宣言した識別子はブロック内でしか参照できない
			func f() {
				n := 100
				println(n)
			}
			func g() {
				n := 200 // 関数fのnとは別のもの
				println(n)
			}
		
		- ファイルスコープ
			- ファイルごとのスコープ
				- ファイル内でインポートしたパッケージを保持するスコープ
				- パッケージ以外は対象としていない
			import "fmt" // fmtがファイルスコープになる

		- パッケージスコープ
			- パッケージごとのスコープ
				- パッケージ単位になる
				- 大文字から始まる識別子は他のパッケージからも参照できる。

		- パッケージ変数
			- 関数間で変数を共有するためには？
				- 関数内で定義した変数は関数を出ると消えてしまう
				- 関数を跨いだデータの共有には2種類ある。
					- パッケージ変数
					- メソッドを用いる
				- 関数と同じレベル変数を定義すればOK

		- ユニバーサルスコープ
			- 組み込み型や組み込み関数を保持するスコープ
				- プログラム実行時からずっと存在するスコープ
				- ルートとなるスコープ
	*/
	f() // main外ののmsgを参照している
	msg = "hi gophers" // 親スコープでmsgを定義しているため:=やvarでなく、=になる。
	f() // このスコープ内のmsg(hi gophers)を参照している
}