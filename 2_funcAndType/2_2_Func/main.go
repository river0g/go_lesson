package main

import (
	"fmt"
)

func main() {
	/* 関数
		- 一連の処理をまとめたもの
			- 引数で受け取った値を基に処理を行い戻り値として結果を返す機能
			- 引数: 関数の龍力となるものf(x)のときx
			- 戻り値(返り値): 関数の出力となるもの
		- 関数の種類
			- 組み込み関数
				- 言語で元々組み込まれている関数
					- print/println(標準出力), make(コンポジット型の初期化), new(指定した型のメモリの確保), len/cap(スライスなどの長さ、容量を返す) 
			- ユーザー定義関数
				- ユーザーが定義した関数

		- 関数呼び出し
			　- 引数を指定して呼び出す
				- 引数は変数や式を指定してもよい
				- 引数が複数ある時はカンマで区切る
				- 戻り値がある場合は変数に代入したり式中で使う
		x := f(10, 1+1, y)

		
		- 関数定義
		fucn add(x int, y int) int {
			return x + y
		}

		- 複数の戻り値を返す
			- 同じ型ならまとめて記述できる
			- 複数の戻り値の時はまるかっこで囲む
			- 複数返り値の時はカンマで区切って戻り値を返す
		func swap(x, y int) (int, int) {
			return y, x
		}

		- 多値(複数戻り値)の受け取り方
			- 間まで区切って受け取ることができる
		x, y := swap(10, 20)
		- 省略したい場合は_(ブランク変数)を用いる
		x, _ := swap(10, 20)
		_ ,y := swap(10, 20)

		- 名前付き戻り値
			- 戻り値に名前が付けられる。
			- 戻り値を明示しない場合は戻り値用の変数の値が返される。
		func swap(x, y int) (x2, y2 int) {
			y2, x2 = x, y
			return
		}
		*/

		x, _ := swap(10, 20)
		_, y := swap(10, 20)
		fmt.Println(x, y)

		/*
		- 値の入れ替え
			- 一次変数なしで値を入れ替えることができる。(Pythonもそう)
		x, y = y, x

		- 無名関数
			- 名前の無い関数のこと
				- クロージャとも呼ばれる
			- 関数外の変数を参照できる。
			- 定義時に即時で呼び出せる
		msg := "Hello, 世界"
		func() {
			println(msg) // この関数の外のmsgを呼び出している
		}() // 無名関数を定義したあとに()をつけることで即時に呼び出している


		- 関数型
			- 関数はファーストクラスオブジェクト
				- 変数への代入
				- 引数に渡す
				- 戻り値で返す
		以下はスライスの要素に関数型を渡している例
	*/
	fs1 := make([]func() string, 2) // 要素に戻り値がstringの即時関数を渡している
	fs1[0] = func() string { return "hoge" }
	fs1[1] = func() string { return "fuga" }
	fmt.Println(fs1[0](), fs1[1]())


	/* クロージャとよくあるバグ
		- 定義と実行のタイミングを気を付ける
			- 関数外の変数(自由変数)を参照している場合
			- 実行のタイミングで値が変わっている可能性がある
	*/
	fs2 := make([]func(), 3)
	for i := range fs2 {
		fs2[i] = func() { fmt.Println(i) }
	}
	for _, f := range fs2 { f() } // 2\n 2\n 2\n
	/* 上記コードの解説
		- make関数で要素が関数, 大きさが3のスライス作成をしている。
		- 1回目のforで上で作成したスライスに標準出力する関数を要素として入れている。出力内容はi
		- 2回目のforでスライス内の関数を実行し標準出力をしている。

		- 出力を見てみると、forで回したはずのiが0,1,2になるはずが全部2になっている。d
		- ここで注意なのが、1回目のforのiについて
			- 1回目のfor内の無名関数は外部のiを参照しているので固定ではない。
			- つまりこの関数の実行時のiが適用される。
			- forで回したiは最後2になるので、出力も全て2になる。
	*/


	/* 値のコピー
		- 代入ではコピーが発生する
			- 代入元と同じ値がコピーされる。
			- コピーのため、代入後の変数に変更を加えても代入前の変数には影響を与えない。
			- 関数の引数や戻り値でも同様のことが起きる(重要)
	*/
	p1 := struct{age int; name string}{age: 28, name:"Jisoo"}
	p2 := p1
	p2.age = 20 // ここではp2のコピー元のp1には影響を与えない
	println(p1.age, p1.name)
	println(p2.age, p2.name)



	/* ポインタ
		- 変数の格納先を表す値
			- 破壊的な操作を加える際に利用する。
				- 破壊的な操作: 関数を出てもその影響が残る。
		- ポインタ型は *型 で表記される
		func f(xp *int) {
			*xp = 100
		}
		
		- ポインタ自体は &変数 で表記する
		var x int // ゼロ値で初期化
		f(&x) // xのポインタを渡している
		println(x) // 100

		- 本来は関数fの引数xpは関数fの使用時の引数のコピーした変数を使用するが、ポインタを渡すことによって関数fの使用時のアドレスを渡すので使用時の引数に影響する。
		- 以下に流れを示す。変数名 | 変数 | アドレス
		x | 0 | 10番地
		↓ f(&x)
		x | 0 | 10番地
		xp | 10番地 | 20番地
		- 上記をみると確かにxp(定義元の引数)はx(関数外の変数)のアドレスを指している。
	*/
	var x1 int
	f(&x1)
	println(x1)


	/* 内部でポインタを使っているデータ型
		- コンポジット型の一部
			- スライス
			- マップ
			- チャネル
		- これらの方はポインタを用いる必要がない場合が多い
	*/
	ns1 := []int{10, 20, 30}
	ns2 := ns1
	ns1[1] = 200
	println(ns1[0], ns1[1], ns1[2]) // 10 200 30
	println(ns2[0], ns2[1], ns2[2]) // 10 200 30
	/*
		- 上記結果より確かにスライスの内部でポインタが用いられている。
		- また、内部でポインタが用いられているだけで、スライス自体は別のもの。
		- その証明として、
		ns1 := []int{10, 20, 30}
		ns2 := ns1
		ns1[1] = 200
		ns1 = append(ns1, 40)
		これでns1とns2を出力すると、ns1しか40が追加されていない。(これは両者の背後にある配列が違うものということ)
	*/



	/*
		Q1. 奇数偶数判定関数
		- i%2 == 0の部分で使用する。
		for i:=1; i<=100; i++ {
			print(i)
			if i%2 == 0 {
				println("-偶数")
			} else {
				println("-奇数")
			}
		}
	*/
	for i:=1; i<=100; i++ {
		print(i)
		if isEven(i) {
			println("-偶数")
		} else {
			println("-奇数")
		}
	}
	


	/*
		Q2. 複数戻り値の利用
		- 値を入れ返すswap関数の実装
		- 以下のコードが正しく動作するように実装してください
		n, m := Qswap(10, 20)
		println(n, m)
	*/
	n, m := Qswap(10, 20)
	println(n, m)


	/*
		Q3. ポインタ
		- 値を入れ替えるQswap2関数を実装してください
		- 次のコードが正しく動作するように実装してください
		n, m := 10, 20
		Qswap2(&n, &m)
		println(n, m)
	*/
	n1, m1 := 10, 20
	Qswap2(&n1, &m1)
	println(n1, m1)


	/* メソッド
		- レシーバと紐づけられた関数
			- func (引数 メソッドを登録する型) メソッド名() 戻り値 {..} で登録する。
			- データとそれに対する操作を紐付けするために用いる
			- ドットでメソッドにアクセスする
		type Hex int
		// Hexのメソッドとして登録
		func (h Hex) String() string {
			return fmt.Sprintf("%x", int(h)) // Sprintf はPrintlnみたいにその場で出力せずに新しい文字列を作成するfmtのメソッド
		}
		
		var hex Hex = 100
		fmt.Println(hex.String()) // Stringメソッドの呼び出し
	*/

	var hex Hex = 100
	fmt.Println(hex.String())

	/* レシーバ
		- メソッドに関連づけられた変数
			- メソッド呼び出し時には通常の引数と同じような扱いになる
				- コピーが発生する
			- ポインタを用いることでレシーバへの変更を呼び出し元に伝えることができる。
				- レシーバがポインタの場合もドットでアクセスする。
		func(t *T)のtがレシーバ。f()のレシーバ(受信者)であるという意味でレシーバと呼ばれる
		type T int
		func (t *T) f() { println("hi") }
		func main () {
			var v T
			(&v).f() // これと、
			v.f() // これは同じ意味。
		}
	*/
	var v T
	(&v).f()
	v.f() // ポインタで渡していない(直接値に対してメソッドを使用している)のに、レシーバにはポインタで渡される。


	/* ポインタ型のメソッドリスト
		*T型はTのメソッドも自身のメソッドとして扱われる
		func (t T) f() {}
		func (t *T) g() {}

		func main() {
			(T{}).f() // T
			(&T{}).f() // *T
			(*&T{}).f() // T

			(T{}).g() // できない
			(&T{}).g()
			(*&T{}).g()
		}

		- (&T{}).f()ができるのはタイトルの通り、言語仕様で「Tのポインタ型もT自身のメソッドとして扱える」から。
		- (T{}).g()ができないのは、関数gのレシーバはポインタを受け取るから。
			- 変数に代入してからメソッドを使う場合はそのままでも扱える。
				- 理由としてはシンタックスシュガーとして、変数で扱う場合はポインタ型でなくても扱える。
		func (t *T) f() {}
		func main() {
			var v T
			(&v).f()
			v.f() // ポインタ型でないのにメソッドが使えるのはシンタックスシュガー
		}
	*/


	/* レシーバにできる型
		- typeで定義した型
			- ユーザー定義型がレシーバにできる
		- ポインタ型
			- レシーバに変更を与えたい場合
		- 内部にポインタを持つ型
			- マップやスライスなどもレシーバにできる
	*/


	/* 
		- Q4. レシーバに変更を与える
		- 次のプログラムを正しく動作するようにしてください。
			- Incメソッドは自信を1づつ加算する
			- 今の実装だと正しく動かない
			- 動かない理由を考え、意図通り動くように修正してください。
		type MyInt int
		func (n MyInt) Inc() { n++ }
		func main() {
			var n MyInt
			println(n)
			n.Inc()
			println(n)
		}

		自分の回答
		レシーバをポインタにする。
	*/
	var qn MyInt
	println(qn)
	qn.Inc()
	println(qn)


	/* メソッド値
		- メソッドも値として扱える
			- レシーバは束縛された状態

		var hex Hex = 100
		f := hex.String
		hex = 200 // メソッドを値として代入したあとにhexを変更しても元のhexが束縛されているので変更は適用されない。
		fmt.Println(f()) // 64

		- ただ、ポインタにした場合は変更される
			- 実行時にポインタの値をみるため。
	*/
	var phex Hex = 100
	ph := &phex
	f1 := ph.PString
	phex = 200 // ここで値を変更するとfの実行結果が変わる。
	fmt.Println(f1()) 


	/* メソッド式
		- メソッドを表す式
			- レシーバを第一引数とした関数になる。
			- レシーバの値が決定していない状態でメソッド値を代入する
			- こちらはインスタンスではなく、型.メソッド名()と書く。
	*/
	var hex1 Hex = 100
	f2 := Hex.String
	fmt.Printf("%T\n%s\n", f2, f2(hex1))

	/*
		メソッド値やメソッド式はテストの時によく使われる
	*/
}
type MyInt int
func (n *MyInt) Inc() { *n++ }


func swap(x, y int) (int, int) {
	return y, x
}

func f(xp *int) { // intのポインタ型
	*xp = 100 // *変数でポインタの示す先に値を入れる。
}

func isEven(num int) bool {
	return num%2 == 0
}

func Qswap(x, y int) (int, int) {
	return y, x
}

func Qswap2(x, y *int){
	*x, *y = *y, *x
}

type Hex int
func (h Hex) String() string {
	return fmt.Sprintf("%x", int(h)) // hを16進数に変える
}
func (h *Hex) PString() string {
	return fmt.Sprintf("%x", int(*h))
}

type T int
func (t *T) f() { println(*t) }