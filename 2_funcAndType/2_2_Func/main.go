package main

import (
	"fmt"
)

func main() {
	/* 関数
		- 一連の処理をまとめたもの
			- 引数で受け取った値を基に処理を行い戻り値として結果を返す機能
			- 引数: 関数の龍力となるものf(x)のときx
			- 戻り値(返り値): 関数の出力となるもの
		- 関数の種類
			- 組み込み関数
				- 言語で元々組み込まれている関数
					- print/println(標準出力), make(コンポジット型の初期化), new(指定した型のメモリの確保), len/cap(スライスなどの長さ、容量を返す) 
			- ユーザー定義関数
				- ユーザーが定義した関数

		- 関数呼び出し
			　- 引数を指定して呼び出す
				- 引数は変数や式を指定してもよい
				- 引数が複数ある時はカンマで区切る
				- 戻り値がある場合は変数に代入したり式中で使う
		x := f(10, 1+1, y)

		
		- 関数定義
		fucn add(x int, y int) int {
			return x + y
		}

		- 複数の戻り値を返す
			- 同じ型ならまとめて記述できる
			- 複数の戻り値の時はまるかっこで囲む
			- 複数返り値の時はカンマで区切って戻り値を返す
		func swap(x, y int) (int, int) {
			return y, x
		}

		- 多値(複数戻り値)の受け取り方
			- 間まで区切って受け取ることができる
		x, y := swap(10, 20)
		- 省略したい場合は_(ブランク変数)を用いる
		x, _ := swap(10, 20)
		_ ,y := swap(10, 20)

		- 名前付き戻り値
			- 戻り値に名前が付けられる。
			- 戻り値を明示しない場合は戻り値用の変数の値が返される。
		func swap(x, y int) (x2, y2 int) {
			y2, x2 = x, y
			return
		}
		*/

		x, _ := swap(10, 20)
		_, y := swap(10, 20)
		fmt.Println(x, y)

		/*
		- 値の入れ替え
			- 一次変数なしで値を入れ替えることができる。(Pythonもそう)
		x, y = y, x

		- 無名関数
			- 名前の無い関数のこと
				- クロージャとも呼ばれる
			- 関数外の変数を参照できる。
			- 定義時に即時で呼び出せる
		msg := "Hello, 世界"
		func() {
			println(msg) // この関数の外のmsgを呼び出している
		}() // 無名関数を定義したあとに()をつけることで即時に呼び出している


		- 関数型
			- 関数はファーストクラスオブジェクト
				- 変数への代入
				- 引数に渡す
				- 戻り値で返す
		以下はスライスの要素に関数型を渡している例
	*/
	fs1 := make([]func() string, 2) // 要素に戻り値がstringの即時関数を渡している
	fs1[0] = func() string { return "hoge" }
	fs1[1] = func() string { return "fuga" }
	fmt.Println(fs1[0](), fs1[1]())


	/* クロージャとよくあるバグ
		- 定義と実行のタイミングを気を付ける
			- 関数外の変数(自由変数)を参照している場合
			- 実行のタイミングで値が変わっている可能性がある
	*/
	fs2 := make([]func(), 3)
	for i := range fs2 {
		fs2[i] = func() { fmt.Println(i) }
	}
	for _, f := range fs2 { f() } // 2\n 2\n 2\n
	/* 上記コードの解説
		- make関数で要素が関数, 大きさが3のスライス作成をしている。
		- 1回目のforで上で作成したスライスに標準出力する関数を要素として入れている。出力内容はi
		- 2回目のforでスライス内の関数を実行し標準出力をしている。

		- 出力を見てみると、forで回したはずのiが0,1,2になるはずが全部2になっている。d
		- ここで注意なのが、1回目のforのiについて
			- 1回目のfor内の無名関数は外部のiを参照しているので固定ではない。
			- つまりこの関数の実行時のiが適用される。
			- forで回したiは最後2になるので、出力も全て2になる。
	*/


	/* 値のコピー
		- 代入ではコピーが発生する
			- 代入元と同じ値がコピーされる。
			- コピーのため、代入後の変数に変更を加えても代入前の変数には影響を与えない。
			- 関数の引数や戻り値でも同様のことが起きる(重要)
	*/
	p1 := struct{age int; name string}{age: 28, name:"Jisoo"}
	p2 := p1
	p2.age = 20 // ここではp2のコピー元のp1には影響を与えない
	println(p1.age, p1.name)
	println(p2.age, p2.name)



	/* ポインタ
		- 変数の格納先を表す値
			- 破壊的な操作を加える際に利用する。
				- 破壊的な操作: 関数を出てもその影響が残る。
		- ポインタ型は *型 で表記される
		func f(xp *int) {
			*xp = 100
		}
		
		- ポインタ自体は &変数 で表記する
		var x int // ゼロ値で初期化
		f(&x) // xのポインタを渡している
		println(x) // 100

		- 本来は関数fの引数xpは関数fの使用時の引数のコピーした変数を使用するが、ポインタを渡すことによって関数fの使用時のアドレスを渡すので使用時の引数に影響する。
		- 以下に流れを示す。変数名 | 変数 | アドレス
		x | 0 | 10番地
		↓ f(&x)
		x | 0 | 10番地
		xp | 10番地 | 20番地
		- 上記をみると確かにxp(定義元の引数)はx(関数外の変数)のアドレスを指している。
	*/
	var x1 int
	f(&x1)
	println(x1)


	/* 内部でポインタを使っているデータ型
		- コンポジット型の一部
			- スライス
			- マップ
			- チャネル
		- これらの方はポインタを用いる必要がない場合が多い
	*/
	ns1 := []int{10, 20, 30}
	ns2 := ns1
	ns1[1] = 200
	println(ns1[0], ns1[1], ns1[2]) // 10 200 30
	println(ns2[0], ns2[1], ns2[2]) // 10 200 30
	/*
		- 上記結果より確かにスライスの内部でポインタが用いられている。
		- また、内部でポインタが用いられているだけで、スライス自体は別のもの。
		- その証明として、
		ns1 := []int{10, 20, 30}
		ns2 := ns1
		ns1[1] = 200
		ns1 = append(ns1, 40)
		これでns1とns2を出力すると、ns1しか40が追加されていない。(これは両者の背後にある配列が違うものということ)
	*/



	/*
		Q1. 奇数偶数判定関数
		- i%2 == 0の部分で使用する。
		for i:=1; i<=100; i++ {
			print(i)
			if i%2 == 0 {
				println("-偶数")
			} else {
				println("-奇数")
			}
		}
	*/
	for i:=1; i<=100; i++ {
		print(i)
		if isEven(i) {
			println("-偶数")
		} else {
			println("-奇数")
		}
	}
	


	/*
		Q2. 複数戻り値の利用
		- 値を入れ返すswap関数の実装
		- 以下のコードが正しく動作するように実装してください
		n, m := Qswap(10, 20)
		println(n, m)
	*/
	n, m := Qswap(10, 20)
	println(n, m)


	/*
		Q3. ポインタ
		- 値を入れ替えるQswap2関数を実装してください
		- 次のコードが正しく動作するように実装してください
		n, m := 10, 20
		Qswap2(&n, &m)
		println(n, m)
	*/
	n1, m1 := 10, 20
	Qswap2(&n1, &m1)
	println(n1, m1)
}

func swap(x, y int) (int, int) {
	return y, x
}

func f(xp *int) { // intのポインタ型
	*xp = 100 // *変数でポインタの示す先に値を入れる。
}

func isEven(num int) bool {
	return num%2 == 0
}

func Qswap(x, y int) (int, int) {
	return y, x
}

func Qswap2(x, y *int){
	*x, *y = *y, *x
}